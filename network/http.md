# [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

### 인터넷 네트워크
- 인터넷 프로토콜 스택의 4계층
    - 애플리케이션 계층: HTTP, FTP
    - 전송 계층: TCP, UDP
    - 인터넷 계층: IP
    - 네트워크 인터페이스 계층
- IP(인터넷 프로토콜)
    - 지정한 IP 주소에 데이터 전달
    - 패킷(Packet)이라는 통신 단위로 데이터 전달
- TCP(전송 제어 프로토콜(Transmission Control Protocol))
    - 연결 지향: **TCP 3 way handshake(가상연결)**
    - 데이터 전달 보증
    - **순서 보장**
    - 신뢰할 수 있는 프로토콜
- UDP(사용자 데이터그램 프로토콜(User Datagram Protocol))
    - 하얀 도화지에 비유(기능이 거의 없음)
    - 연결 지향: TCP 3 way handshake X
    - 데이터 전달 보증 X
    - 순서 보장 X
    - 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
    - IP 와 거의 같다. + **PORT** + 체크섬 정도만 추가
    - 애플리케이션에서 추가 작업 필요
- PORT
    - 0 ~ 65535 할당 가능
    - 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음
    - FTP: 20, 21
    - TELNET: 23
    - HTTP: 80
    - HTTPS: 443
- DNS(도메인 네임 시스템(Domain Name System))
     - 도메인명을 IP 주소로 반환
    
### URI 와 웹 브라우저 요청 흐름
- **URI**(Uniform Resource Identifier)
    - Uniform: 리소스 식별하는 통일된 방식
    - Resource: 자원, URI 로 식별할 수 있는 모든 것(제한 없음)
    - Identifier: 다른 항목과 구분하는데 필요한 정보
    - **URL**(Uniform Resource **Locator**)
    - **URN**(Uniform Resource **Name**)
- URL, URN
    - Locator: 리소스가 있는 위치를 지정
    - Name: 리소스에 이름을 부여
    - 위치는 변할 수 있지만, 이름은 변하지 않는다.
    - URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음

### HTTP 기본
- HTTP 역사
    - HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
    - HTTP/1.0 1996년: 메서드, 헤더 추가
    - HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전
    - RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
    - HTTP/2 2015년: 성능 개선
    - HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선
- 기반 프로토콜
    - TCP: HTTP/1.1, HTTP/2
    - UDP: HTTP/3
    - 현재 HTTP/1.1 주로 사용
        - HTTP/2 HTTP/3 도 점점 증가
- 무상태 프로토콜
    - 스테이트리스(Stateless)
    - 서버가 클라이언트의 상태를 보존 X
    - 장점: 서버 확장성 높음(스케일 아웃)
    - 단점: 클라이언트가 추가 데이터 전송
- stateful, stateless 차이
    - **상태 유지**: 중간에 다른 점원으로 바뀌면 안된다.(중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)
    - **무상태**: 중간에 다른 서버로 바뀌어도 된다.
        - 갑자기 고객이 증가해도 점원을 대거 투입 할 수 있다.
        - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입 할 수 있다.
    - 무상태는 응답 서버를 쉽게 바꿀 수 있다. -> **무한한 서버 증설 가능**
- stateless 실무 한계
    - 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
    - 무상태: 예) 로그인이 필요 없는 단순한 서비스 소개 화면
    - 상태 유지: 예) 로그인
    - 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
    - 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
    - 상태 유지는 최소한만 사용
- 비 연결성(connectionless)
    - HTTP 는 기본이 연결을 유지하지 않는 모델
    - 일반 적으로 초 단위 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
        - 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
    - 서버 자원을 매우 효율적으로 사용할 수 있음
    - 한계와 극복
        - TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
        - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 js, css, image 등 수 많은 자원이 함께 다운로드 
        - 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 
        - HTTP/2, HTTP/3 에서 더 많은 최적화
- HTTP 메시지
    - ~~~ http request
      GET /search?q=hello&hl=ko HTTP/1.1
      host: www.google.com
      ~~~
    - start-line = request-line / status-line
    - request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)
    - status-line = HTTP-version SP status-code SP reason-phrase CRLF
    
### HTTP 메서드
- API URI 고민
    - 리소스의 의미는 뭘까?
        - 회원을 등록하고 수정하고 조회하는게 리소스가 아니다!
        - 예) 미네랄을 캐라 -> 미네랄이 리소스!
        - **회원이라는 개념 자체가 바로 리스소다.**
    - 리소스를 어떻게 식별하는게 좋을까
        - 회원을 등록하고 수정하고 조회하는 것을 모두 배제
        - **회원이라는 리소스만 식별하면 된다. -> 회원 리소스를 URI 에 매핑**
    - 리소스와 행위를 분리
        - 가장 중요한 것은 리소스를 식별하는 것
        - **URI 는 리소스만 식별**
        - **리소스**와 해당 리소스를 대상으로 하는 **행위**를 분리
            - 리소스: 회원
            - 행위: 조회, 등록, 삭제, 변경
        - 리소스는 명사, 행위는 동사
- HTTP 메서드 종류
    - GET: 리소스 조회
    - POST: 요청 데이터 처리, 주로 등록에 사용
    - PUT: 리소스를 대체, 해당 리소스가 없으면 생성
    - PATCH: 리소스 부분 변경
    - DELETE: 리소스 삭제
    - HEAD: GET 과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
    - OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS 에서 사용)
    - CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
    - TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
- GET
    - 리소스 조회
    - 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
    - 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음 
- POST
    - 요청 데이터 처리
    - **메시지 바디를 통해 서버로 요청 데이터 전달**
    - 서버는 요청 데이터를 처리
    - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행
    - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
- PUT
    - **리소스를 대체**
        - 리소스가 있으면 **기존 리소스를 통채로 대체**
        - 리소스가 없으면 생성
        - 쉽게 이야기해서 덮어버림
    - **클라이언트가 리소스를 식별**(예: /members/100)
        - 클라이언트가 리소스 위치를 알고 URI 지정
- PATCH
    - 리소스의 부분 변경
    - 간혹 지원하지 않는 서버가 있다.
- DELETE
    - 리소스 제거
- HTTP 메서드의 속성
    - 안전(Safe)
        - 호출해도 리소스를 변경하지 않는다.
        - Q: 그래도 계속 호출해서, 로그 같은게 쌓여서 장애가 발생하면요?
        - A: 안전은 해당 리소스만 고려한다. 그런 부분까지 고려하지 않는다.
    - 멱등(Idempotent): 한 번 호출하든 두 번 호출하든 N 번 호출하든 결과가 똑같다.
        - GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다. 
        - PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다. 
        - DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
        - **POST: 멱등이 아니다!** 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.
        - **멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지는 않는다.**
    - 캐시가능(Cacheable)
        - GET, HEAD, POST, PATCH 캐시가능
            - 실제로는 GET, HEAD 정도만 캐시로 사용
            - POST, PATCH 는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음
    
### HTTP 메서드 활용
- [참고하면 좋은 URI 설계 개념](https://restfulapi.net/resource-naming)
    - **문서(document)**
        - 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
        - 예) /members/100, / les/star.jpg
    - **컬렉션(collection)**
        - 서버가 관리하는 리소스 디렉터리
        - 서버가 리소스의 URI 를 생성하고 관리
        - 예) /members
    - **스토어(store)**
        - 클라이언트가 관리하는 자원 저장소
        - 클라이언트가 리소스의 URI 를 알고 관리
        - 예) / les
    - **컨트롤러(controller), 컨트롤 URI**
        - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
        - 동사를 직접 사용
        - 예) /members/{id}/delete
    
### HTTP 상태코드
- *1xx (Informational): 요청이 수신되어 처리중*(잘사용하지 않음)
- 2xx (Successful): 요청 정상 처리
    - 200 OK
    - 201 Created
    - 202 Accepted
        - 요청이 접수되었으나 처리가 완료되지 않았음
        - 배치 처리 같은 곳에서 사용. 예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함
    - 204 No Content
- 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요
    - *300 Multiple Choices*(잘안씀)
    - 301 Moved Permanently
    - 302 Found
    - 303 See Other
    - 304 Not Modified
        - 캐시를 목적으로 사용
        - 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC 에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
        - 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로)
    - 307 Temporary Redirect
    - 308 Permanent Redirect
    - 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)
    - 영구 리다이렉션(301, 308) - 잘안쓴다.
        - 리소스의 URI 가 영구적으로 이동
        - 원래의 URL 를 사용X, 검색 엔진 등에서도 변경 인지
        - 301 Moved Permanently
            - 리다이렉트시 요청 메서드가 GET 으로 변하고, 본문이 제거될 수 있음(MAY)
        - 308 Permanent Redirect
            - 301과 기능은 같음
            - 리다이렉트시 요청 메서드와 본문 유지(처음 POST 를 보내면 리다이렉트도 POST 유지)
    - 일시적인 리다이렉션(302,307,303)
        - 리소스의 URI 가 일시적으로 변경
        - 따라서 검색 엔진 등에서 URL 을 변경하면 안됨
        - 302 Found
            - 리다이렉트시 요청 메서드가 GET 으로 변하고, 본문이 제거될 수 있음(MAY)
        - 307 Temporary Redirect
            - 302와 기능은 같음
            - 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다. MUST NOT)
        - 303 See Other
            - 302와 기능은 같음
            -리다이렉트시 요청 메서드가 GET 으로 변경
    - PRG(Post/Redirect/Get) - 일시적인 리다이렉션 예시
        - POST 로 주문후에 새로 고침으로 인한 중복 주문 방지 
        - POST 로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트 
        - 새로고침해도 결과 화면을 GET 으로 조회
        - 중복 주문 대신에 결과 화면만 GET 으로 다시 요청
    - 현실
        - 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용
        - 자동 리다이렉션시에 GET 으로 변해도 되면 그냥 302를 사용해도 큰 문제 없음
- 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
    - 400 Bad Request
        - 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음 
        - 요청 구문, 메시지 등등 오류
        - 클라이언트는 요청 내용을 다시 검토하고, 보내야함 
        - 예) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때
    - 401 Unauthorized
        - 클라이언트가 해당 리소스에 대한 인증이 필요함
        - 인증(Authentication) 되지 않음
        - 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
        - **인증(Authentication): 본인이 누구인지 확인, (로그인)**
        - **인가(Authorization): 권한부여 (ADMIN 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있음)**
    - 403 Forbidden 
        - 서버가 요청을 이해했지만 승인을 거부함
        - 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우
        - 예) 어드민 등급이 아닌 사용자가 로그인은 했지만, 어드민 등급의 리소스에 접근하는 경우
    - 404 Not Found
        - 요청 리소스를 찾을 수 없음
        - 요청 리소스가 서버에 없음
        - 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때
- 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
    - 500 Internal Server Error
        - 서버 문제로 오류 발생, 애매하면 500 오류
        - 서버 내부 문제로 오류 발생
        - 애매하면 500 오류
    - 503 Service Unavailable
        - 서비스 이용 불가
        - 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
        - Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음
    
### HTTP 헤더1 - 일반 헤더
- General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close
- Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)
- Response 헤더: 응답 정보, 예) Server: Apache
- Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423
- 표현(요청이나 응답에서 실제 전달할 데이터)
    - Content-Type: 표현 데이터의 형식
    - Content-Encoding: 표현 데이터의 압축 방식
    - Content-Language: 표현 데이터의 자연 언어
    - Content-Length: 표현 데이터의 길이
- 협상(클라이언트가 선호하는 표현 요청)
    - 협상 헤더는 요청시에만 사용
    - Accept: 클라이언트가 선호하는 미디어 타입 전달
    - Accept-Charset: 클라이언트가 선호하는 문자 인코딩
    - Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
    - Accept-Language: 클라이언트가 선호하는 자연 언어
- 협상과 우선순위(Quality Values(q))
    - 0~1, 클수록 높은 우선순위
    - 생략하면 1
    - 구체적인 것이 우선한다.
    - 예) Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
- 쿠키
    - 예) set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure
    - 사용처
        - 사용자 로그인 세션 관리
        - 광고 정보 트래킹
    - 쿠키 정보는 항상 서버에 전송됨
        - 네트워크 트래픽 추가 유발
        - 최소한의 정보만 사용(세션 id, 인증 토큰)
        - 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStorage) 참고
    - **보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)**
- 쿠키 생명주기 
    - Set-Cookie: **expires**=Sat, 26-Dec-2020 04:39:21 GMT
        - 만료일이 되면 쿠키 삭제 
    - Set-Cookie: **max-age**=3600 (3600초)
        - 0이나 음수를 지정하면 쿠키 삭제
    - 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
    - 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
    
### HTTP 헤더2 - 캐시와 조건부 요청
- 검증 헤더와 조건부 요청 
    - 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답(바디X)
    - 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
    - 클라이언트는 캐시에 저장되어 있는 데이터 재활용
    - 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 하게 되어 매우 실용적인 해결책이다.
- 검증 헤더
    - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
    - Last-Modified , ETag
- 조건부 요청 헤더
    - 검증 헤더로 조건에 따른 분기
    - If-Modified-Since: Last-Modified 사용
    - If-None-Match: ETag 사용
    - 조건이 만족하면 200 OK
    - 조건이 만족하지 않으면 304 Not Modified
- ETag(Entity Tag)
    - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
        - 예) ETag: "v1.0", ETag: "a2jiodwjekjl3"
    - 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
        - 예) ETag: "aaaaa" -> ETag: "bbbbb"
    - 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!
- 캐시 지시어(directives) - 확실한 캐시 무효화
    - Cache-Control: no-cache
        - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
    - Cache-Control: no-store
        - 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
    - Cache-Control: must-revalidate
        - 캐시 만료후 최초 조회시 원 서버에 검증해야함
        - 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)
        - must-revalidate 는 캐시 유효 시간이라면 캐시를 사용함
    - Pragma: no-cache
        - HTTP 1.0 하위 호환